### Function Types
Functions have a data type in Go, which means they can be assigned to variables and used as function parameters, arguments, and results.
```go
package main 
import "fmt" 
func calcWithTax(price float64) float64 { 
	return price + (price * 0.2) 
} 
func calcWithoutTax(price float64) float64 { 
	return price 
} 
func main() { 
	products := map[string]float64 { 
		"Kayak" : 275, 
		"Lifejacket": 48.95, 
	} 
	for product, price := range products { 
		var calcFunc func(float64) float64 
		if (price > 100) { calcFunc = calcWithTax } 
		else { calcFunc = calcWithoutTax } 
		totalPrice := calcFunc(price) 
		fmt.Println("Product:", product, "Price:", totalPrice) 
	} 
}
```

Checking for Assignment
```go
var calcFunc func(float64) float64
fmt.Println("Function assigned:", calcFunc == nil)
```

### Functions as Arguments
```go
import "fmt" 
func calcWithTax(price float64) float64 { 
	return price + (price * 0.2) 
} 
func calcWithoutTax(price float64) float64 { 
	return price 
} 
func printPrice(product string, price float64, calculator func(float64) float64 ) {
	fmt.Println("Product:", product, "Price:", calculator(price)) 
} 
func main() { 
	products := map[string]float64 { 
		"Kayak" : 275, 
		"Lifejacket": 48.95, 
	} 
	for product, price := range products { 
		if (price > 100) { 
			printPrice(product, price, calcWithTax) 
		} else { 
			printPrice(product, price, calcWithoutTax) 
		} 
	} 
}
```

### Functions as Results
```go
package main 
import "fmt" 
func calcWithTax(price float64) float64 { 
	return price + (price * 0.2) 
} 
func calcWithoutTax(price float64) float64 { 
	return price 
} 
func printPrice(product string, price float64, calculator func(float64) float64 ) { 
	fmt.Println("Product:", product, "Price:", calculator(price)) 
}
func selectCalculator(price float64) func(float64) float64 { 
	if (price > 100) { 
		return calcWithTax 
	} 
	return calcWithoutTax 
} 
func main() { 
	products := map[string]float64 { 
		"Kayak" : 275, 
		"Lifejacket": 48.95, 
	} 
	for product, price := range products { 
		printPrice(product, price, selectCalculator(price)) 
	} 
}
```

### Function Type Aliases
```go
package main 
import "fmt" 
type calcFunc func(float64) float64 
func calcWithTax(price float64) float64 { 
	return price + (price * 0.2) 
} 
func calcWithoutTax(price float64) float64 { 
	return price 
} 
func printPrice(product string, price float64, calculator calcFunc) {
	fmt.Println("Product:", product, "Price:", calculator(price)) 
} 
func selectCalculator(price float64) calcFunc { 
	if (price > 100) { 
		return calcWithTax 
	} 
	return calcWithoutTax 
} 
func main() { 
	products := map[string]float64 { 
		"Kayak" : 275, 
		"Lifejacket": 48.95, 
	} 
	for product, price := range products { 
		printPrice(product, price, selectCalculator(price)) 
	} 
}
```

### Literal Function Syntax
```go
package main 
import "fmt" 
type calcFunc func(float64) float64 
func printPrice(product string, price float64, calculator calcFunc) { 
	fmt.Println("Product:", product, "Price:", calculator(price)) 
} 
func selectCalculator(price float64) calcFunc { 
	if (price > 100) { 
		var withTax calcFunc = func (price float64) float64 { 
			return price + (price * 0.2) 
		} 
		return withTax 
	}
	withoutTax := func (price float64) float64 { 
		return price 
	} 
	return withoutTax 
} 
func main() { 
	products := map[string]float64 { 
		"Kayak" : 275, 
		"Lifejacket": 48.95, 
	} 
	for product, price := range products { 
		printPrice(product, price, selectCalculator(price)) 
	} 
}
```


### Function Closure
Functions defined using the literal syntax can reference variables from the surrounding code, a feature known as closure. This feature can be difficult to understand, so I am going to start with an example that doesn’t rely on closure.Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.

For example, the `adder` function returns a closure. Each closure is bound to its own `sum` variable.
```go
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
```

### First Class Functions
A language that supports first class functions allows functions to be assigned to variables, passed as arguments to other functions and returned from other functions. Go has support for first class functions.
```go
package main

import (  
    "fmt"
)

func main() {  
    a := func() {
        fmt.Println("hello world first class function")
    }
    a()
    fmt.Printf("%T", a)
}
```